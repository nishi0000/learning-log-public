


## 目的

Lambda と API Gateway をつないだ状態で、  
「とりあえず動く API」を作り、動作確認できるようにするため。

## 本筋

- API Gateway から Lambda を呼ぶとき、  
    Lambda 側は **どんな入力を受け取り、どんな形で返す必要があるのか**を理解する。
    
- 「Lambda 単体の関数」と「HTTP API」の違いを整理する。
    

## 結論

API Gateway 経由で Lambda を呼ぶ場合、  
Lambda は **string を受け取って string を返す関数**では動かない。  
HTTP リクエストを受け取り、HTTP レスポンスの形で返す必要がある。

## 図解

```text
（うまくいかなかったとき）

ブラウザ
 └ HTTP GET /todos
    └ API Gateway
       └ Lambda
          └ string input -> string output（想定）
              × 型が合わず 500 エラー


（修正後）

ブラウザ
 └ HTTP GET /todos
    └ API Gateway
       └ Lambda
          └ APIGatewayProxyRequest を受け取る
          └ APIGatewayProxyResponse を返す
              ○ JSON が表示される
```

## 詳細

### 実際にやったこと

- C# の Lambda プロジェクトをテンプレートから作成した
    
- API Gateway（HTTP API）を作成し、`GET /todos` を Lambda に接続した
    
- ブラウザで  
    `https://xxxxx.execute-api.ap-northeast-1.amazonaws.com/prod/todos`  
    にアクセスした
    
- `{"message":"Internal Server Error"}` が返ってきた
    

### 起きていたエラー

- CloudWatch Logs に以下のエラーが出ていた
    
    - JSON を `System.String` に変換できない
        
    - `StartObject` を string として読めない、という内容
        

### 実際に起きていたこと

- API Gateway 経由では、
    
    - Lambda は **HTTP リクエスト全体をオブジェクトとして受け取る**
        
    - 返り値も **HTTP レスポンス形式**で返す必要がある
        
- それなのに、
    
    - string を前提にした関数を動かそうとしていたため
        
    - 入力の型が合わず、Lambda 実行時に 500 エラーになっていた
        

### 修正内容

- Lambda の関数シグネチャを以下の形に変更した
    

```csharp
public APIGatewayProxyResponse FunctionHandler(
    APIGatewayProxyRequest request,
    ILambdaContext context)
```

- 返り値を `APIGatewayProxyResponse` にした
    
- `StatusCode`, `Body`, `Headers` を明示的に設定した
    

### 結果

- 再デプロイ後、同じ URL にアクセスすると
    

```json
{"message":"hello from lambda"}
```

が表示された  
→ API Gateway → Lambda → ブラウザ の流れが正常に動作した
