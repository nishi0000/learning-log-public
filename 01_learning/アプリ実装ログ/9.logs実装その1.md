# 実装ログ（事実ログ）— AWS × C#（.NET 8）× Vue：`POST /logs` DTOデシリアライズ〜echo、ルーティング分岐、レスポンス共通化

更新日時: 2026-01-15 +0900（会話日時ベース）


---

## 1. 作業目的

- `/logs` に POST した JSON を Lambda で受け取り、`LogsRequest` DTO に Deserialize できることを確認する
    
- 受け取った内容をレスポンスに含めて返す（echo）ことで入力到達を確定する
    
- 400（bodyなし/空）→ `{"error":"empty body"}`
    
- 400（JSON不正）→ `{"error":"invalid json"}`
    
- 500（想定外）→ `{"error":"internal error"}`
    
- ルート未定義 → 404 `{"error":"not found"}`
    

---

## 2. 作業対象（環境）

- API: API Gateway（HTTP API） + AWS Lambda（C# / .NET 8）
    
- 検証: PowerShell（`curl.exe`）
    
- ログ確認: CloudWatch Logs
    
- Lambda入力: `APIGatewayHttpApiV2ProxyRequest`
    
- Lambda出力: `APIGatewayHttpApiV2ProxyResponse`
    
- JSON: `System.Text.Json`
    

---

## 3. 実施内容と結果

### 3.1 ルーティング分岐の方針整理（POST内で path 分岐）

**何をした**

- `method == "POST"` ブロック内で `path` により `/logs` と `/todos` を分岐する構造に変更
    
- DTOを共通変数（`dto` 1つ）で扱うのをやめ、ルート内ローカルで扱う方針に変更
    

**何が起きた**

- `/logs` 用 DTO と `/todos` 用 DTO を同一変数で扱うと型不整合・参照プロパティ不一致（`title/completed` vs `ts/type/text`）が発生する前提が明確化した
    

**現在どうなっている**

- `POST` 時に `path` で明確に分岐し、各ルートで専用 DTO を Deserialize する構造が確定
    

---

### 3.2 `EndsWith("/logs")` による末尾判定の導入

**何をした**

- `path == "/logs"` の完全一致ではなく、`path.EndsWith("/logs")` に変更
    
- `path != null` の null ガードを追加
    

**何が起きた**

- ステージ名などがパスに含まれるケース（例：`/prod/logs`）でも `/logs` ルート判定できる作りに変更した
    

**現在どうなっている**

- `/logs` の判定は `path != null && path.EndsWith("/logs")` により末尾一致で処理される状態
    

---

### 3.3 POST Body 空判定（共通）

**何をした**

- `var body = request.Body;` を取り出し
    
- `string.IsNullOrWhiteSpace(body)` の場合に 400 を返す処理を維持
    
- 返却は共通メソッド `BadRequest("empty body")` を使用
    

**何が起きた**

- Body なし/空での 400 応答が返る構造が維持された
    

**現在どうなっている**

- POST 共通で Body 空の場合は `{"error":"empty body"}` を返す
    

---

### 3.4 `/logs` の Deserialize と echo（LogsRequest）

**何をした**

- `public record LogsRequest(DateTime ts, string type, string text);` を使用
    
- `/logs` 分岐内で `JsonSerializer.Deserialize<LogsRequest>(body)` を実行
    
- `dto == null` の場合は 400 `invalid json`
    
- 正常時は `{ id = 999, ts, type, text }` を作成し `Ok(created)` で返却
    

**何が起きた**

- JSON不正時は `JsonException` を捕捉し 400 を返す
    
- 想定外例外は 500 を返す
    
- 正常 JSON で echo の形（`id/ts/type/text`）を返す構造に到達
    

**現在どうなっている**

- `POST /logs` は LogsRequest へ Deserialize を試行し、成功時は 200 で echo を返す実装が存在する
    

---

### 3.5 `/todos` の Deserialize と echo（TodoCreateRequest）

**何をした**

- `public record TodoCreateRequest(string title, bool completed);` を使用
    
- `/todos` 分岐内で `JsonSerializer.Deserialize<TodoCreateRequest>(body)` を実行
    
- `dto == null` の場合は 400 `invalid json`
    
- 正常時は `{ id = 999, completed, title }` を作成し `Ok(created)` で返却
    

**何が起きた**

- `/logs` と同様の例外処理方針（400/500）で統一した
    

**現在どうなっている**

- `POST /todos` は TodoCreateRequest へ Deserialize を試行し、成功時は 200 で echo を返す実装が存在する
    

---

### 3.6 未定義パスの扱い（404 Not Found）

**何をした**

- `POST` で `/logs` と `/todos` 以外のパスに対して `NotFound()` を返すよう変更
    

**何が起きた**

- JSON不正（400）とルーティング未定義（404）を分離した
    

**現在どうなっている**

- 未定義パスは 404 `{"error":"not found"}` を返す
    

---

### 3.7 レスポンス生成の共通化（Ok/BadRequest/ServerError/NotFound）

**何をした**

- 200/400/500/404 のレスポンス生成を private メソッドへ集約
    
    - `Ok(object obj)`：`JsonSerializer.Serialize(obj)` して 200 を返す
        
    - `BadRequest(string message)`：400 を返す
        
    - `ServerError()`：500 を返す
        
    - `NotFound()`：404 を返す
        
- 各レスポンスで `Content-Type: application/json` を付与
    

**何が起きた**

- ルート処理の本体が「判定→Deserialize→echo→return」に寄り、重複コードが減少した
    

**現在どうなっている**

- レスポンス生成は共通メソッド経由で返す構造に確定
    

---

### 3.8 GET の挙動（現状）

**何をした**

- `POST` 以外のメソッド（GET想定）では固定の todos 配列を `Ok(todos)` で返す処理を維持
    

**何が起きた**

- GET 時は `[{ id, title, completed }, ...]` を返す
    

**現在どうなっている**

- `method != "POST"` の場合、固定 todo 一覧を 200 で返す
    

---

## 4. 検証（仕様・コマンド）

### 4.1 Body なし（400 empty body）

**何をした**

- `POST /logs` を Body なしで実行（URLはマスク）
    

**コマンド例**

```powershell
curl.exe -i -X POST -H "Content-Type: application/json" {API_BASE_URL}/prod/logs
```

**期待結果**

- `HTTP/1.1 400 Bad Request`
    
- `{"error":"empty body"}`
    

---

### 4.2 JSON 不正（400 invalid json）

**何をした**

- 壊れた JSON を送信
    

**コマンド例**

```powershell
curl.exe -i -X POST -H "Content-Type: application/json" -d "{broken...}" {API_BASE_URL}/prod/logs
```

**期待結果**

- `HTTP/1.1 400 Bad Request`
    
- `{"error":"invalid json"}`
    

---

### 4.3 正常 JSON（200 echo）

**リクエスト例**

```json
{
  "ts":"2026-01-12T21:00:00+09:00",
  "type":"note",
  "text":"test log"
}
```

**期待結果（例）**

- `HTTP/1.1 200 OK`
    
- `{"id":999,"ts":"...","type":"note","text":"test log"}`
    

---

## 5. 最終状態（確定）

- Lambda ハンドラは `method == "POST"` の場合に `path` で `/logs` と `/todos` を分岐する
    
- `/logs` は `path != null && path.EndsWith("/logs")` で判定し、`LogsRequest` に Deserialize して echo を返す
    
- `/todos` は `TodoCreateRequest` に Deserialize して echo を返す
    
- Body 空は 400 `{"error":"empty body"}`
    
- JSON不正（Deserialize失敗/JsonException）は 400 `{"error":"invalid json"}`
    
- 想定外例外は 500 `{"error":"internal error"}`
    
- 未定義パスは 404 `{"error":"not found"}`
    
- レスポンス生成は `Ok / BadRequest / ServerError / NotFound` に共通化され、`Content-Type: application/json` を付与する
    

---